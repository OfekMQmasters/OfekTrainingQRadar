category: Analytics & SIEM
commonfields:
  id: qradar_ofek_training
  version: -1
configuration:
- additionalinfo: The IP Address of QRadar Console. e.g.,1.1.1.1
  display: Console IP address
  name: ip_address
  required: true
  type: 0
- additionalinfo: The API key for QRadar API. Called SEC in the console.
  display: QRadar API key
  name: api_key
  required: true
  type: 4
- additionalinfo: Trust any certificate (not secure)
  defaultvalue: 'false'
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days.
  defaultvalue: '30'
  display: First fetch time
  name: fetch_time
  required: false
  type: 0
- additionalinfo: Max number of alerts per fetch. Defaults to 20, max is 1000.
  defaultvalue: '50'
  display: Fetch Limit
  name: max_fetch
  required: false
  type: 0
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: IBM QRadar collects, processes, aggregates, and stores network data in
  real time. QRadar uses that data to manage network security by providing real-time
  information and monitoring, alerts and offenses, and responses to network threats
detaileddescription: ''
display: QRadar Ofek Training
name: qradar_ofek_training
script:
  commands:
  - deprecated: false
    description: Retrieves the current system information of the QRadar console.
    execution: false
    name: qradar-ofek-training-retrieve-about-information
    outputs:
    - contextPath: QRadarOfekTraining.About.release_name
      description: QRadar system's release name
      type: String
    - contextPath: QRadarOfekTraining.About.build_version
      description: QRadar system's build version
      type: String
    - contextPath: QRadarOfekTraining.About.external_version
      description: QRadar system's external version
      type: String
  - arguments:
    - default: false
      description: 'An optional time range. i.e: 3 months, 1 week, 1 day ago, etc.'
      isArray: false
      name: time_range
      required: false
      secret: false
    - default: false
      description: 'Start time. format: YYYY-mm-ddTHH:MM:SSZ or 3 months, 1 week,
        1 day ago, etc.Given only the start_time, end_time will be set to the current
        time.'
      isArray: false
      name: start_time
      required: false
      secret: false
    - default: false
      description: 'End time. format: YYYY-mm-ddTHH:MM:SSZ or i.e: 3 months, 1 week,
        1 day ago, etc.Given only the start_time, end_time will be set to the current
        time.'
      isArray: false
      name: end_time
      required: false
      secret: false
    deprecated: false
    description: Execute search query of events which were created in a specific time
      interval.
    execution: false
    name: qradar-ofek-training-search-events-initialize
    outputs:
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.cursor_id
      description: search query id
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.status
      description: search execution status
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.compressed_data_file_count
      description: number of compressed files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.compressed_data_total_size
      description: total size of compressed files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.data_file_count
      description: number of  files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.data_total_size
      description: total size of files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.index_file_count
      description: number of index files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.index_total_size
      description: total size of index files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.processed_record_count
      description: count number of processed records (events) found in the search
        query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.desired_retention_time_msec
      description: search query's retention time
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.progress
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.query_execution_time
      description: start time of the search query execution
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.query_string
      description: string of the search query itself
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.record_count
      description: count number of records (events) found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.size_on_disk
      description: size left on the disk of the console
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.save_results
      description: save or to not to save the results (events) which fetched from
        the search query
      type: Boolean
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.completed
      description: the search query is completed or not
      type: Boolean
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.snapshot
      type: Unknown
    - contextPath: QRadarOfekTraining.SearchEventsInitialize.search_id
      description: the id of the search. useful for another commands
      type: String
  - arguments:
    - default: false
      description: id of search execution
      isArray: false
      name: search_id
      required: true
      secret: true
    deprecated: false
    description: 'Get the current status of the search query :  COMPLETED/ EXECUTING/
      WAITING/ ERROR.'
    execution: false
    name: qradar-ofek-training-search-events-status
    outputs:
    - contextPath: QRadarOfekTraining.SearchEventsStatus.cursor_id
      description: search query id
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsStatus.status
      description: search execution status
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsStatus.compressed_data_file_count
      description: number of compressed files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.compressed_data_total_size
      description: total size of compressed files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.data_file_count
      description: number of  files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.data_total_size
      description: total size of files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.index_file_count
      description: number of index files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.index_total_size
      description: total size of index files found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.processed_record_count
      description: count number of processed records (events) found in the search
        query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.desired_retention_time_msec
      description: search query's retention time
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.progress
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.query_execution_time
      description: start time of the search query execution
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.query_string
      description: string of the search query itself
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsStatus.record_count
      description: count number of records (events) found in the search query
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.size_on_disk
      description: size left on the disk of the console
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsStatus.save_results
      description: save or to not to save the results (events) which fetched from
        the search query
      type: Boolean
    - contextPath: QRadarOfekTraining.SearchEventsStatus.completed
      description: the search query is completed or not
      type: Boolean
    - contextPath: QRadarOfekTraining.SearchEventsStatus.snapshot
      type: Unknown
    - contextPath: QRadarOfekTraining.SearchEventsStatus.search_id
      description: the id of the search. useful for another commands
      type: Number
  - arguments:
    - default: false
      description: id of search execution
      isArray: false
      name: search_id
      required: false
      secret: false
    deprecated: false
    description: Retrieve the events (QRadar logs) in QRadar, which were fetched by
      the search query.
    execution: false
    name: qradar-ofek-training-search-events-results
    outputs:
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.starttime
      description: event start time
      type: Date
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.protocolid
      description: protocol id of the event(log)(
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.sourceip
      description: source ip of the event(where the log created)
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.logsourceid
      description: source id of the endpoint where the log created
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.qid
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.sourceport
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.eventcount
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.magnitude
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.identityip
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.destinationip
      type: String
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.destinationport
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.category
      type: Number
    - contextPath: QRadarOfekTraining.SearchEventsResults.events.username
      type: Unknown
  - arguments:
    - default: true
      defaultValue: 'true'
      description: active ARadar rules
      isArray: false
      name: enabled
      required: false
      secret: true
    deprecated: false
    description: list QRadar rules.
    execution: false
    name: qradar-ofek-training-list-rules
    outputs:
    - contextPath: QRadarOfekTraining.ListRules.owner
      description: QRadar rule's creator
      type: String
    - contextPath: QRadarOfekTraining.ListRules.identifier
      description: QRadar rule's id
      type: String
    - contextPath: QRadarOfekTraining.ListRules.base_host_id
      description: QRadar rule's base host id
      type: Number
    - contextPath: QRadarOfekTraining.ListRules.capacity_timestamp
      description: 'rule timestamp '
      type: Number
    - contextPath: QRadarOfekTraining.ListRules.origin
      description: rule's origin
      type: String
    - contextPath: QRadarOfekTraining.ListRules.creation_date
      description: rule's creation date
      type: Date
    - contextPath: QRadarOfekTraining.ListRules.type
      description: rule's type
      type: String
    - contextPath: QRadarOfekTraining.ListRules.enabled
      description: active\non active rule
      type: Boolean
    - contextPath: QRadarOfekTraining.ListRules.modification_date
      description: 'last modification date '
      type: Date
    - contextPath: QRadarOfekTraining.ListRules.linked_rule_identifier
      description: linked rules id
      type: Unknown
    - contextPath: QRadarOfekTraining.ListRules.name
      description: rule name
      type: String
    - contextPath: QRadarOfekTraining.ListRules.average_capacity
      description: rule's average capacity
      type: Number
    - contextPath: QRadarOfekTraining.ListRules.id
      description: rule id
      type: Number
    - contextPath: QRadarOfekTraining.ListRules.base_capacity
      description: rule base capacity
      type: Number
  dockerimage: demisto/python3:3.8.3.8715
  feed: false
  isfetch: true
  longRunning: false
  longRunningPort: false
  runonce: false
  script: |-
    import json
    import urllib3
    import dateparser
    import traceback
    from typing import Any, Dict, Tuple, List, Optional, Union, cast

    # Disable insecure warnings
    urllib3.disable_warnings()


    ''' CONSTANTS '''


    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    MAX_INCIDENTS_TO_FETCH = 50
    HELLOWORLD_SEVERITIES = ['Low', 'Medium', 'High', 'Critical']

    ''' CLIENT CLASS '''


    class Client(BaseClient):

        def __init__(self, ip_address: str, api_key: str, proxy: bool, insecure: bool):
            """initializing a client instance with authentication header

            Args:
                ip_address (str): QRadar console's IP address
                api_key (str): The API key for QRadar API.
                proxy (bool): proxy settings
                insecure (bool): insecure settings
            """
            base_url = f'https://{ip_address}/api'
            headers = {
                'SEC': api_key,
                'Version': '15.0',
                'Accept': 'application/json'
            }
            super().__init__(base_url, insecure, proxy, headers=headers)

        def get_system_about(self) -> Dict[str, Any]:
            """Retrieves the current system information of the QRadar console.

            Returns:
                Dict[str, Any]: response json
            """

            return self._http_request(
                method='GET',
                url_suffix='/system/about'
            )



    ''' HELPER FUNCTIONS '''


    def parse_domain_date(domain_date: Union[List[str], str], date_format: str = '%Y-%m-%dT%H:%M:%S.000Z') -> Optional[str]:
        """Converts whois date format to an ISO8601 string

        Converts the HelloWorld domain WHOIS date (YYYY-mm-dd HH:MM:SS) format
        in a datetime. If a list is returned with multiple elements, takes only
        the first one.

        :type domain_date: ``Union[List[str],str]``
        :param date_format:
            a string or list of strings with the format 'YYYY-mm-DD HH:MM:SS'

        :return: Parsed time in ISO8601 format
        :rtype: ``Optional[str]``
        """

        if isinstance(domain_date, str):
            # if str parse the value
            domain_date_dt = dateparser.parse(domain_date)
            if domain_date_dt:
                return domain_date_dt.strftime(date_format)
        elif isinstance(domain_date, list) and len(domain_date) > 0 and isinstance(domain_date[0], str):
            # if list with at least one element, parse the first element
            domain_date_dt = dateparser.parse(domain_date[0])
            if domain_date_dt:
                return domain_date_dt.strftime(date_format)
        # in any other case return nothing
        return None


    def convert_to_demisto_severity(severity: str) -> int:
        """Maps HelloWorld severity to Cortex XSOAR severity

        Converts the HelloWorld alert severity level ('Low', 'Medium',
        'High', 'Critical') to Cortex XSOAR incident severity (1 to 4)
        for mapping.

        :type severity: ``str``
        :param severity: severity as returned from the HelloWorld API (str)

        :return: Cortex XSOAR Severity (1 to 4)
        :rtype: ``int``
        """

        # In this case the mapping is straightforward, but more complex mappings
        # might be required in your integration, so a dedicated function is
        # recommended. This mapping should also be documented.
        return {
            'Low': IncidentSeverity.LOW,
            'Medium': IncidentSeverity.MEDIUM,
            'High': IncidentSeverity.HIGH,
            'Critical': IncidentSeverity.CRITICAL
        }[severity]


    ''' COMMAND FUNCTIONS '''


    def test_module(client: Client, first_fetch_time: int) -> str:
        """Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type name: ``str``
        :param name: name to append to the 'Hello' string

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """

        # INTEGRATION DEVELOPER TIP
        # Client class should raise the exceptions, but if the test fails
        # the exception text is printed to the Cortex XSOAR UI.
        # If you have some specific errors you want to capture (i.e. auth failure)
        # you should catch the exception here and return a string with a more
        # readable output (for example return 'Authentication Error, API Key
        # invalid').
        # Cortex XSOAR will print everything you return different than 'ok' as
        # an error
        try:
            client.get_system_about()
        # except requests.exceptions.ConnectionError as e:

        except DemistoException as e:
            if 'unauthorized' in str(e):
                return 'Authorization Error: make sure API Key is correctly set'
            elif 'server URL' in str(e):
                return 'Connection Error: make sure your IP address is correctly set'
            else:
                raise e
        return 'ok'


    def say_hello_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """helloworld-say-hello command: Returns Hello {somename}

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``str``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['name']`` is used as input name

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains the hello world message

        :rtype: ``CommandResults``
        """

        # INTEGRATION DEVELOPER TIP
        # In this case 'name' is an argument set in the HelloWorld.yml file as mandatory,
        # so the null check here as XSOAR will always check it before your code is called.
        # Although it's not mandatory to check, you are welcome to do so.

        name = args.get('name', None)
        if not name:
            raise ValueError('name not specified')

        # Call the Client function and get the raw response
        result = client.say_hello(name)

        # Create the human readable output.
        # It will  be in markdown format - https://www.markdownguide.org/basic-syntax/
        # More complex output can be formatted using ``tableToMarkDown()`` defined
        # in ``CommonServerPython.py``
        readable_output = f'## {result}'

        # More information about Context:
        # https://xsoar.pan.dev/docs/integrations/context-and-outputs
        # We return a ``CommandResults`` object, and we want to pass a custom
        # markdown here, so the argument ``readable_output`` is explicit. If not
        # passed, ``CommandResults``` will do a ``tableToMarkdown()`` do the data
        # to generate the readable output.
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='hello',
            outputs_key_field='',
            outputs=result
        )


    def fetch_incidents(client: Client, max_results: int, last_run: Dict[str, int],
                        first_fetch_time: Optional[int], alert_status: Optional[str],
                        min_severity: str, alert_type: Optional[str]
                        ) -> Tuple[Dict[str, int], List[dict]]:


        # Get the last fetch time, if exists
        # last_run is a dict with a single key, called last_fetch
        last_fetch = last_run.get('last_fetch', None)
        # Handle first fetch time
        if last_fetch is None:
            # if missing, use what provided via first_fetch_time
            last_fetch = first_fetch_time
        else:
            # otherwise use the stored last fetch
            last_fetch = int(last_fetch)

        # for type checking, making sure that latest_created_time is int
        latest_created_time = cast(int, last_fetch)

        # Initialize an empty list of incidents to return
        # Each incident is a dict with a string as a key
        incidents: List[Dict[str, Any]] = []

        # Get the CSV list of severities from min_severity
        severity = ','.join(HELLOWORLD_SEVERITIES[HELLOWORLD_SEVERITIES.index(min_severity):])

        alerts = client.search_alerts(
            alert_type=alert_type,
            alert_status=alert_status,
            max_results=max_results,
            start_time=last_fetch,
            severity=severity
        )

        for alert in alerts:
            # If no created_time set is as epoch (0). We use time in ms so we must
            # convert it from the HelloWorld API response
            incident_created_time = int(alert.get('created', '0'))
            incident_created_time_ms = incident_created_time * 1000

            # to prevent duplicates, we are only adding incidents with creation_time > last fetched incident
            if last_fetch:
                if incident_created_time <= last_fetch:
                    continue

            # If no name is present it will throw an exception
            incident_name = alert['name']

            # INTEGRATION DEVELOPER TIP
            # The incident dict is initialized with a few mandatory fields:
            # name: the incident name
            # occurred: the time on when the incident occurred, in ISO8601 format
            # we use timestamp_to_datestring() from CommonServerPython.py to
            # handle the conversion.
            # rawJSON: everything else is packed in a string via json.dumps()
            # and is included in rawJSON. It will be used later for classification
            # and mapping inside XSOAR.
            # severity: it's not mandatory, but is recommended. It must be
            # converted to XSOAR specific severity (int 1 to 4)
            # Note that there are other fields commented out here. You can do some
            # mapping of fields (either out of the box fields, like "details" and
            # "type") or custom fields (like "helloworldid") directly here in the
            # code, or they can be handled in the classification and mapping phase.
            # In either case customers can override them. We leave the values
            # commented out here, but you can use them if you want.
            incident = {
                'name': incident_name,
                # 'details': alert['name'],
                'occurred': timestamp_to_datestring(incident_created_time_ms),
                'rawJSON': json.dumps(alert),
                # 'type': 'Hello World Alert',  # Map to a specific XSOAR incident Type
                'severity': convert_to_demisto_severity(alert.get('severity', 'Low')),
                # 'CustomFields': {  # Map specific XSOAR Custom Fields
                #     'helloworldid': alert.get('alert_id'),
                #     'helloworldstatus': alert.get('alert_status'),
                #     'helloworldtype': alert.get('alert_type')
                # }
            }

            incidents.append(incident)

            # Update last run and add incident if the incident is newer than last fetch
            if incident_created_time > latest_created_time:
                latest_created_time = incident_created_time

        # Save the next_run as a dict with the last_fetch key to be stored
        next_run = {'last_fetch': latest_created_time}
        return next_run, incidents


    def ip_reputation_command(client: Client, args: Dict[str, Any], default_threshold: int) -> List[CommandResults]:
        """ip command: Returns IP reputation for a list of IPs

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['ip']`` is a list of IPs or a single IP
            ``args['threshold']`` threshold to determine whether an IP is malicious

        :type default_threshold: ``int``
        :param default_threshold:
            default threshold to determine whether an IP is malicious
            if threshold is not specified in the XSOAR arguments

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains IPs

        :rtype: ``CommandResults``
        """

        # INTEGRATION DEVELOPER TIP
        # Reputation commands usually support multiple inputs (i.e. arrays), so
        # they can be invoked once in XSOAR. In this case the API supports a single
        # IP at a time, so we will cycle this for all the members of the array.
        # We use argToList(), implemented in CommonServerPython.py to automatically
        # return a list of a single element even if the provided input is a scalar.

        ips = argToList(args.get('ip'))
        if len(ips) == 0:
            raise ValueError('IP(s) not specified')

        # It's a good practice to document the threshold you use to determine
        # if a score is malicious in your integration documentation.
        # Thresholds should also be possible to override, as in this case,
        # where threshold is an actual argument of the command.
        threshold = int(args.get('threshold', default_threshold))

        # Initialize an empty list of CommandResults to return
        # each CommandResult will contain context standard for IP
        command_results: List[CommandResults] = []

        for ip in ips:
            ip_data = client.get_ip_reputation(ip)
            ip_data['ip'] = ip

            # HelloWorld score to XSOAR reputation mapping
            # See: https://xsoar.pan.dev/docs/integrations/dbot
            # We are using Common.DBotScore as macros to simplify
            # the mapping.

            score = 0
            reputation = int(ip_data.get('score', 0))
            if reputation == 0:
                score = Common.DBotScore.NONE  # unknown
            elif reputation >= threshold:
                score = Common.DBotScore.BAD  # bad
            elif reputation >= threshold / 2:
                score = Common.DBotScore.SUSPICIOUS  # suspicious
            else:
                score = Common.DBotScore.GOOD  # good

            # The context is bigger here than other commands, as it consists in 3
            # parts: the vendor-specific context (HelloWorld), the standard-context
            # (IP) and the DBotScore.
            # More information:
            # https://xsoar.pan.dev/docs/integrations/context-and-outputs
            # https://xsoar.pan.dev/docs/integrations/context-standards
            # https://xsoar.pan.dev/docs/integrations/dbot
            # Also check the HelloWorld Design Document

            # Create the DBotScore structure first using the Common.DBotScore class.
            dbot_score = Common.DBotScore(
                indicator=ip,
                indicator_type=DBotScoreType.IP,
                integration_name='HelloWorld',
                score=score,
                malicious_description=f'Hello World returned reputation {reputation}'
            )

            # Create the IP Standard Context structure using Common.IP and add
            # dbot_score to it.
            ip_standard_context = Common.IP(
                ip=ip,
                asn=ip_data.get('asn'),
                dbot_score=dbot_score
            )

            # INTEGRATION DEVELOPER TIP
            # In the integration specific Context output (HelloWorld.IP) in this
            # example you want to provide a lot of information as it can be used
            # programmatically from within Cortex XSOAR in playbooks and commands.
            # On the other hand, this API is way to verbose, so we want to select
            # only certain keys to be returned in order not to clog the context
            # with useless information. What to actually return in the context and
            # to define as a command output is subject to design considerations.

            # INTEGRATION DEVELOPER TIP
            # To generate the Context Outputs on the YML use ``demisto-sdk``'s
            # ``json-to-outputs`` option.

            # Define which fields we want to exclude from the context output as
            # they are too verbose.
            ip_context_excluded_fields = ['objects', 'nir']
            ip_data = {k: ip_data[k] for k in ip_data if k not in ip_context_excluded_fields}

            # In this case we want to use an custom markdown to specify the table title,
            # but otherwise ``CommandResults()`` will call ``tableToMarkdown()``
            #  automatically
            readable_output = tableToMarkdown('IP', ip_data)

            # INTEGRATION DEVELOPER TIP
            # The output key will be ``HelloWorld.IP``, using ``ip`` as the key field.
            # ``indicator`` is used to provide the context standard (IP)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='HelloWorld.IP',
                outputs_key_field='ip',
                outputs=ip_data,
                indicator=ip_standard_context
            ))
        return command_results


    def domain_reputation_command(client: Client, args: Dict[str, Any], default_threshold: int) -> List[CommandResults]:
        """domain command: Returns domain reputation for a list of domains

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['domain']`` list of domains or a single domain
            ``args['threshold']`` threshold to determine whether a domain is malicious

        :type default_threshold: ``int``
        :param default_threshold:
            default threshold to determine whether an domain is malicious
            if threshold is not specified in the XSOAR arguments

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains Domains

        :rtype: ``CommandResults``
        """

        # INTEGRATION DEVELOPER TIP
        # Reputation commands usually support multiple inputs (i.e. arrays), so
        # they can be invoked once in XSOAR. In this case the API supports a single
        # IP at a time, so we will cycle this for all the members of the array.
        # We use argToList(), implemented in CommonServerPython.py to automatically
        # return a list of a single element even if the provided input is a scalar.

        domains = argToList(args.get('domain'))
        if len(domains) == 0:
            raise ValueError('domain(s) not specified')

        threshold = int(args.get('threshold', default_threshold))

        # Initialize an empty list of CommandResults to return,
        # each CommandResult will contain context standard for Domain
        command_results: List[CommandResults] = []

        for domain in domains:
            domain_data = client.get_domain_reputation(domain)
            domain_data['domain'] = domain

            # INTEGRATION DEVELOPER TIP
            # We want to convert the dates to ISO8601 as
            # Cortex XSOAR customers and integrations use this format by default
            if 'creation_date' in domain_data:
                domain_data['creation_date'] = parse_domain_date(domain_data['creation_date'])
            if 'expiration_date' in domain_data:
                domain_data['expiration_date'] = parse_domain_date(domain_data['expiration_date'])
            if 'updated_date' in domain_data:
                domain_data['updated_date'] = parse_domain_date(domain_data['updated_date'])

            # HelloWorld score to XSOAR reputation mapping
            # See: https://xsoar.pan.dev/docs/integrations/dbot
            # We are using Common.DBotScore as macros to simplify
            # the mapping.

            score = 0
            reputation = int(domain_data.get('score', 0))
            if reputation == 0:
                score = Common.DBotScore.NONE  # unknown
            elif reputation >= threshold:
                score = Common.DBotScore.BAD  # bad
            elif reputation >= threshold / 2:
                score = Common.DBotScore.SUSPICIOUS  # suspicious
            else:
                score = Common.DBotScore.GOOD  # good

            # INTEGRATION DEVELOPER TIP
            # The context is bigger here than other commands, as it consists in 3
            # parts: the vendor-specific context (HelloWorld), the standard-context
            # (Domain) and the DBotScore.
            # More information:
            # https://xsoar.pan.dev/docs/integrations/context-and-outputs
            # https://xsoar.pan.dev/docs/integrations/context-standards
            # https://xsoar.pan.dev/docs/integrations/dbot
            # Also check the sample Design Document

            dbot_score = Common.DBotScore(
                indicator=domain,
                integration_name='HelloWorld',
                indicator_type=DBotScoreType.DOMAIN,
                score=score,
                malicious_description=f'Hello World returned reputation {reputation}'
            )

            # Create the Domain Standard Context structure using Common.Domain and
            # add dbot_score to it.
            domain_standard_context = Common.Domain(
                domain=domain,
                creation_date=domain_data.get('creation_date', None),
                expiration_date=domain_data.get('expiration_date', None),
                updated_date=domain_data.get('updated_date', None),
                organization=domain_data.get('org', None),
                name_servers=domain_data.get('name_servers', None),
                registrant_name=domain_data.get('name', None),
                registrant_country=domain_data.get('country', None),
                registrar_name=domain_data.get('registrar', None),
                dbot_score=dbot_score
            )

            # In this case we want to use an custom markdown to specify the table title,
            # but otherwise ``CommandResults()`` will call ``tableToMarkdown()``
            #  automatically
            readable_output = tableToMarkdown('Domain', domain_data)

            # INTEGRATION DEVELOPER TIP
            # The output key will be ``HelloWorld.Domain``, using ``domain`` as the key
            # field.
            # ``indicator`` is used to provide the context standard (Domain)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='HelloWorld.Domain',
                outputs_key_field='domain',
                outputs=domain_data,
                indicator=domain_standard_context
            ))
        return command_results


    def search_alerts_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """helloworld-search-alerts command: Search alerts in HelloWorld

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['status']`` alert status. Options are 'ACTIVE' or 'CLOSED'
            ``args['severity']`` alert severity CSV
            ``args['alert_type']`` alert type
            ``args['start_time']``  start time as ISO8601 date or seconds since epoch
            ``args['max_results']`` maximum number of results to return

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains alerts

        :rtype: ``CommandResults``
        """

        status = args.get('status')

        # Check if severity contains allowed values, use all if default
        severities: List[str] = HELLOWORLD_SEVERITIES
        severity = args.get('severity', None)
        if severity:
            severities = severity.split(',')
            if not all(s in HELLOWORLD_SEVERITIES for s in severities):
                raise ValueError(
                    f'severity must be a comma-separated value '
                    f'with the following options: {",".join(HELLOWORLD_SEVERITIES)}')

        alert_type = args.get('alert_type')

        # Convert the argument to a timestamp using helper function
        start_time = arg_to_datetime(
            arg=args.get('start_time'),
            arg_name='start_time',
            required=False
        )

        # Convert the argument to an int using helper function
        max_results = arg_to_number(
            arg=args.get('max_results'),
            arg_name='max_results',
            required=False
        )

        # Severity is passed to the API as a CSV
        alerts = client.search_alerts(
            severity=','.join(severities),
            alert_status=status,
            alert_type=alert_type,
            start_time=int(start_time.timestamp()) if start_time else None,
            max_results=max_results
        )

        # INTEGRATION DEVELOPER TIP
        # We want to convert the "created" time from timestamp(s) to ISO8601 as
        # Cortex XSOAR customers and integrations use this format by default
        for alert in alerts:
            if 'created' not in alert:
                continue
            created_time_ms = int(alert.get('created', '0')) * 1000
            alert['created'] = timestamp_to_datestring(created_time_ms)

        # in this example we are not providing a custom markdown, we will
        # let ``CommandResults`` generate it by default.
        return CommandResults(
            outputs_prefix='HelloWorld.Alert',
            outputs_key_field='alert_id',
            outputs=alerts
        )


    def get_alert_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """helloworld-get-alert command: Returns a HelloWorld alert

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['alert_id']`` alert ID to return

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains an alert

        :rtype: ``CommandResults``
        """

        alert_id = args.get('alert_id', None)
        if not alert_id:
            raise ValueError('alert_id not specified')

        alert = client.get_alert(alert_id=alert_id)

        # INTEGRATION DEVELOPER TIP
        # We want to convert the "created" time from timestamp(s) to ISO8601 as
        # Cortex XSOAR customers and integrations use this format by default
        if 'created' in alert:
            created_time_ms = int(alert.get('created', '0')) * 1000
            alert['created'] = timestamp_to_datestring(created_time_ms)

        # tableToMarkdown() is defined is CommonServerPython.py and is used very
        # often to convert lists and dicts into a human readable format in markdown
        readable_output = tableToMarkdown(f'HelloWorld Alert {alert_id}', alert)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='HelloWorld.Alert',
            outputs_key_field='alert_id',
            outputs=alert
        )


    def update_alert_status_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """helloworld-update-alert-status command: Changes the status of an alert

        Changes the status of a HelloWorld alert and returns the updated alert info

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['alert_id']`` alert ID to update
            ``args['status']`` new status, either ACTIVE or CLOSED

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains an updated alert

        :rtype: ``CommandResults``
        """

        alert_id = args.get('alert_id', None)
        if not alert_id:
            raise ValueError('alert_id not specified')

        status = args.get('status', None)
        if status not in ('ACTIVE', 'CLOSED'):
            raise ValueError('status must be either ACTIVE or CLOSED')

        alert = client.update_alert_status(alert_id, status)

        # INTEGRATION DEVELOPER TIP
        # We want to convert the "updated" time from timestamp(s) to ISO8601 as
        # Cortex XSOAR customers and integrations use this format by default
        if 'updated' in alert:
            updated_time_ms = int(alert.get('updated', '0')) * 1000
            alert['updated'] = timestamp_to_datestring(updated_time_ms)

        # tableToMarkdown() is defined is CommonServerPython.py and is used very
        # often to convert lists and dicts into a human readable format in markdown
        readable_output = tableToMarkdown(f'HelloWorld Alert {alert_id}', alert)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='HelloWorld.Alert',
            outputs_key_field='alert_id',
            outputs=alert
        )


    def scan_start_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """helloworld-start-scan command: Starts a HelloWorld scan

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['hostname']`` hostname to run the scan on

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains a scan job

        :rtype: ``CommandResults``
        """

        hostname = args.get('hostname', None)
        if not hostname:
            raise ValueError('hostname not specified')

        scan = client.scan_start(hostname=hostname)

        # INTEGRATION DEVELOPER TIP
        # The API doesn't return the hostname of the scan it was called against,
        # which is the input. It could be useful to have that information in the
        # XSOAR context, so we are adding it manually here, based on the command
        # input argument.
        scan['hostname'] = hostname

        scan_id = scan.get('scan_id')

        readable_output = f'Started scan {scan_id}'

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='HelloWorld.Scan',
            outputs_key_field='scan_id',
            outputs=scan
        )


    def scan_status_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """helloworld-scan-status command: Returns status for HelloWorld scans

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['scan_id']`` list of scan IDs or single scan ID

        :return:
            A ``CommandResults`` object that is then passed to ``return_results``,
            that contains a scan status

        :rtype: ``CommandResults``
        """

        scan_id_list = argToList(args.get('scan_id', []))
        if len(scan_id_list) == 0:
            raise ValueError('scan_id(s) not specified')

        scan_list: List[Dict[str, Any]] = []
        for scan_id in scan_id_list:
            scan = client.scan_status(scan_id=scan_id)
            scan_list.append(scan)

        readable_output = tableToMarkdown('Scan status', scan_list)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='HelloWorld.Scan',
            outputs_key_field='scan_id',
            outputs=scan_list
        )


    def scan_results_command(client: Client, args: Dict[str, Any]) -> Union[Dict[str, Any], CommandResults, List[CommandResults]]:
        """helloworld-scan-results command: Returns results for a HelloWorld scan

        :type client: ``Client``
        :param Client: HelloWorld client to use

        :type args: ``Dict[str, Any]``
        :param args:
            all command arguments, usually passed from ``demisto.args()``.
            ``args['scan_id']`` scan ID to retrieve results
            ``args['format']`` format of the results. Options are 'file' or 'json'

        :return:
            A ``CommandResults`` compatible to return ``return_results()``,
            that contains a scan result when json format is selected, or
            A Dict of entries also compatible to ``return_results()`` that
            contains the output file when file format is selected.

        :rtype: ``Union[Dict[str, Any],CommandResults]``
        """

        scan_id = args.get('scan_id', None)
        if not scan_id:
            raise ValueError('scan_id not specified')

        scan_format = args.get('format', 'file')

        # INTEGRATION DEVELOPER TIP
        # This function supports returning data in multiple formats, either in a json
        # format that is then mapped to a table, or as a file attachment.
        # In this case, if the format is "file", the return value is different and
        # uses a raw format  and ``fileResult()`` directly instead of
        # ``CommandResults``. In either case you should return data to main and
        # call ``return_results()`` from there.
        # Always use ``CommandResults`` when possible but, if you need to return
        # anything special like a file, you can use this raw format.

        results = client.scan_results(scan_id=scan_id)
        if scan_format == 'file':
            return (
                fileResult(
                    filename=f'{scan_id}.json',
                    data=json.dumps(results, indent=4),
                    file_type=entryTypes['entryInfoFile']
                )
            )
        elif scan_format == 'json':
            # This scan returns CVE information. CVE is also part of the XSOAR
            # context standard, so we must extract CVE IDs and return them also.
            # See: https://xsoar.pan.dev/docs/integrations/context-standards#cve
            cves: List[Common.CVE] = []
            command_results: List[CommandResults] = []
            entities = results.get('entities', [])
            for e in entities:
                if 'vulns' in e.keys() and isinstance(e['vulns'], list):
                    cves.extend([Common.CVE(id=c, cvss=None, published=None, modified=None, description=None) for c in e['vulns']])

            # INTEGRATION DEVELOPER TIP
            # We want to provide a unique result for every CVE indicator.
            # Since every entity may contain several CVE indicators,
            # we will split the entities result and CVE indicator results.
            readable_output = tableToMarkdown(f'Scan {scan_id} results', entities)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='HelloWorld.Scan',
                outputs_key_field='scan_id',
                outputs=results
            ))

            cves = list(set(cves))  # make the indicator list unique
            for cve in cves:
                command_results.append(CommandResults(
                    readable_output=f"CVE {cve}",
                    indicator=cve
                ))
            return command_results
        else:
            raise ValueError('Incorrect format, must be "json" or "file"')


    ''' MAIN FUNCTION '''


    def main() -> None:
        """main function, parses params and runs command functions

        :return:
        :rtype:
        """
        params = demisto.params()
        ip_address = params.get('ip_address')
        api_key = params.get('api_key')
        insecure = not params.get('insecure', False)
        proxy = params.get('proxy', False)

        first_fetch_time = arg_to_datetime(
            arg=demisto.params().get('first_fetch', '3 days'),
            arg_name='First fetch time',
            required=True
        )
        first_fetch_timestamp = int(first_fetch_time.timestamp()) if first_fetch_time else None
        # Using assert as a type guard (since first_fetch_time is always an int when required=True)
        assert isinstance(first_fetch_timestamp, int)

        # if your Client class inherits from BaseClient, system proxy is handled
        # out of the box by it, just pass ``proxy`` to the Client constructor
        # proxy = demisto.params().get('proxy', False)

        # INTEGRATION DEVELOPER TIP
        # You can use functions such as ``demisto.debug()``, ``demisto.info()``,
        # etc. to print information in the XSOAR server log. You can set the log
        # level on the server configuration
        # See: https://xsoar.pan.dev/docs/integrations/code-conventions#logging

        demisto.debug(f'Command being called is {demisto.command()}')
        try:

            client = Client(
                ip_address=ip_address,
                api_key=api_key,
                insecure=insecure,
                proxy=proxy)

            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                result = test_module(client, first_fetch_timestamp)
                return_results(result)

            # elif demisto.command() == 'fetch-incidents':
            #     # Set and define the fetch incidents command to run after activated via integration settings.
            #     alert_status = demisto.params().get('alert_status', None)
            #     alert_type = demisto.params().get('alert_type', None)
            #     min_severity = demisto.params().get('min_severity', None)
            #
            #     # Convert the argument to an int using helper function or set to MAX_INCIDENTS_TO_FETCH
            #     max_results = arg_to_number(
            #         arg=demisto.params().get('max_fetch'),
            #         arg_name='max_fetch',
            #         required=False
            #     )
            #     if not max_results or max_results > MAX_INCIDENTS_TO_FETCH:
            #         max_results = MAX_INCIDENTS_TO_FETCH
            #
            #     next_run, incidents = fetch_incidents(
            #         client=client,
            #         max_results=max_results,
            #         last_run=demisto.getLastRun(),  # getLastRun() gets the last run dict
            #         first_fetch_time=first_fetch_timestamp,
            #         alert_status=alert_status,
            #         min_severity=min_severity,
            #         alert_type=alert_type
            #     )
            #
            #     # saves next_run for the time fetch-incidents is invoked
            #     demisto.setLastRun(next_run)
            #     # fetch-incidents calls ``demisto.incidents()`` to provide the list
            #     # of incidents to create
            #     demisto.incidents(incidents)
            #
            # elif demisto.command() == 'ip':
            #     default_threshold_ip = int(demisto.params().get('threshold_ip', '65'))
            #     return_results(ip_reputation_command(client, demisto.args(), default_threshold_ip))
            #
            # elif demisto.command() == 'domain':
            #     default_threshold_domain = int(demisto.params().get('threshold_domain', '65'))
            #     return_results(domain_reputation_command(client, demisto.args(), default_threshold_domain))
            #
            # elif demisto.command() == 'helloworld-say-hello':
            #     return_results(say_hello_command(client, demisto.args()))
            #
            # elif demisto.command() == 'helloworld-search-alerts':
            #     return_results(search_alerts_command(client, demisto.args()))
            #
            # elif demisto.command() == 'helloworld-get-alert':
            #     return_results(get_alert_command(client, demisto.args()))
            #
            # elif demisto.command() == 'helloworld-update-alert-status':
            #     return_results(update_alert_status_command(client, demisto.args()))
            #
            # elif demisto.command() == 'helloworld-scan-start':
            #     return_results(scan_start_command(client, demisto.args()))
            #
            # elif demisto.command() == 'helloworld-scan-status':
            #     return_results(scan_status_command(client, demisto.args()))
            #
            # elif demisto.command() == 'helloworld-scan-results':
            #     return_results(scan_results_command(client, demisto.args()))

        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
image: data:image/png;base64,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
